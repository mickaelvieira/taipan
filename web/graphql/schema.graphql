# The Go GraphQL library does not support markdown documentation
# so the lines are commented out for now

scalar URL
scalar DateTime

schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

type Query {
  users: UsersQuery
  documents: DocumentsQuery
  bookmarks: BookmarksQuery
  feeds: FeedsQuery
  syndication: SyndicationQuery
}

type Mutation {
  bookmarks: BookmarksMutation
  syndication: SyndicationMutation
}

type Subscription {
  # "Subscribes to news feed events"
  news(): DocumentEvent!

  # "Subscribes to favorites feed events"
  favorites(): BookmarkEvent!

  # "Subscribes to reading list feed events"
  readingList(): BookmarkEvent!
}

type UsersQuery {
  # "Returns the current logged in user"
  loggedIn(): User
}

type DocumentsQuery {
  # "Returns a list of documents"
  documents(pagination: CursorPaginationInput!): DocumentCollection
}

type BookmarksQuery {
  # "Returns the bookmark matching the URL"
  bookmark(url: URL!): Bookmark
}

type BookmarksMutation {
  # """
  # This mutation will fetch the document and create a bookmark
  # Which will be present in user's reading list
  # """
  create(url: URL!, withFeeds: Boolean!): Bookmark

  # """
  # This mutation will add the document and create a bookmark
  # It will be present in user's reading list or favorites depending
  # on the isFavorite flag
  # """
  add(url: URL!, isFavorite: Boolean!): Bookmark

  # "This mutation will add the document to users's bookmarks."
  remove(url: URL!): Document

  # "This mutation will add the bookmark to users's favorites."
  favorite(url: URL!): Bookmark

  # "This mutation will remove the bookmark from users's favorites."
  unfavorite(url: URL!): Bookmark
}

type FeedsQuery {
  # "Returns the list of latest news shown in the feed"
  news(pagination: CursorPaginationInput!): FeedDocumentResults

  # "Returns the list of latest news when polling documents"
  latestNews(pagination: CursorPaginationInput!): FeedDocumentResults

  # "Returns the users's favorite bookmarks"
  favorites(pagination: CursorPaginationInput!): FeedBookmarkResults

  # "Returns the users's reading list"
  readingList(pagination: CursorPaginationInput!): FeedBookmarkResults
}

type SyndicationQuery {
  # "Returns a list of web syndication sources"
  sources(pagination: OffsetPaginationInput!, search: SearchSourcesInput!): SourceCollection
}

type SyndicationMutation {
  # "Returns a web syndication source matching the URL"
  source(url: URL!): Source

  # "Enable the web syndication source matching the URL"
  enable(url: URL!): Source

  # "Disable the web syndication source matching the URL"
  disable(url: URL!): Source

  # "Delete the web syndication source matching the URL"
  delete(url: URL!): Source
}

input SearchSourcesInput {
  isPaused: Boolean!
}

input CursorPaginationInput {
  from: String
  to: String
  limit: Int
}

input OffsetPaginationInput {
  offset: Int
  limit: Int
}

interface Node {
  id: ID!
}

# """
# The user type represents a user of the application
# """
type User implements Node {
  id: ID!
  firstname: String!
  lastname: String!
  username: String!
}

# """
# The Image type represents a HTML document hero image.
# Usually it is either the Facebook or the Twitter image
# """
type Image {
  name: String!
  url: URL!
  width: Int!
  height: Int!
  format: String!
}

# """
# The Document type represents a web document.
# It may be a bookmark
# """
type Document implements Node {
  id: ID!
  url: URL!
  lang: String!
  charset: String!
  title: String!
  description: String!
  image: Image
  createdAt: DateTime!
  updatedAt: DateTime!
  logEntries: [HTTPClientLog]
}

# """
# The Bookmark type represents a web document but
# from a user's bookmark perspective
# """
type Bookmark implements Node {
  id: ID!
  url: URL!
  lang: String!
  charset: String!
  title: String!
  description: String!
  image: Image
  updatedAt: DateTime!
  addedAt: DateTime!
  isFavorite: Boolean!
}

# """
# The source type describe a web syndication source.
# It can be either a RSS or Atom feed
# """
type Source implements Node {
  id: ID!
  url: URL!
  type: String!
  title: String!
  status: String!
  isPaused: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  parsedAt: DateTime!
  logEntries: [HTTPClientLog]
}

# "The HTTPClientLog type describes an entry in the HTTP client history"
type HTTPClientLog implements Node {
  id: ID!
  checksum: String!
  requestURI: URL!
  # finalURI: URL!
  statusCode: Int!
  contentType: String!
  createdAt: DateTime!
}

# "A collection of web documents"
type DocumentCollection {
  first: String!
  last: String!
  total: Int!
  limit: Int!
  results: [Document!]!
}

# "A collection of web syndication sources"
type SourceCollection {
  offset: Int!
  total: Int!
  limit: Int!
  results: [Source!]!
}

# "An item in a feed"
union FeedItem = Bookmark | Document

interface FeedResults {
  # "First cursor"
  first: String!

  # "Last cursor"
  last: String!

  # "Total number of possible results"
  total: Int!

  # "Total number of results"
  limit: Int!

  # "List of results"
  results: [FeedItem!]!
}

type FeedDocumentResults implements FeedResults {
  first: String!
  last: String!
  total: Int!
  limit: Int!
  results: [Document!]!
}

type FeedBookmarkResults implements FeedResults {
  first: String!
  last: String!
  total: Int!
  limit: Int!
  results: [Bookmark!]!
}

# """
# When subscribing to a feed, the subsciption will send events to add.
# When a item is added to or removed from a feed, the subscription will notify
# the client in order to keep the feed up to date.
# """

# "A topic represents a feed"
enum FeedTopic {
  News
  Favorites
  ReadingList
}

# "A action represents a action on an item in the feed"
enum FeedAction {
  Add
  Remove
}

# "A event describes an action on an item in a given topic"
interface FeedEvent {
  id: String!
  item: FeedItem!
  topic: FeedTopic!
  action: FeedAction!
}

type DocumentEvent implements FeedEvent {
  id: String!
  item: Document!
  topic: FeedTopic!
  action: FeedAction!
}

type BookmarkEvent implements FeedEvent {
  id: String!
  item: Bookmark!
  topic: FeedTopic!
  action: FeedAction!
}
