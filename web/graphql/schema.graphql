
# Custom scalars
scalar URL
scalar DateTime

# Schema
schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

type Query {
  users(): UsersQuery
  documents: DocumentsQuery
  bookmarks: BookmarksQuery
  feeds: FeedsQuery
  syndication: SyndicationQuery
}

type Mutation {
  bookmarks: BookmarksMutation
  syndication: SyndicationMutation
}

type Subscription {
  news(): DocumentEvent!
  favorites(): BookmarkEvent!
  readingList(): BookmarkEvent!
}

# Users queries and mutations
type UsersQuery {
  loggedIn(): User
}

# Documents queries and mutations
type DocumentsQuery {
  documents(pagination: CursorPaginationInput!): DocumentCollection
}

# Bookmarks queries and mutations
type BookmarksQuery {
  bookmark(url: URL!): Bookmark
}

type BookmarksMutation {
  create(url: URL!): Bookmark
  add(url: URL!, isFavorite: Boolean!): Bookmark
  remove(url: URL!): Document
  favorite(url: URL!): Bookmark
  unfavorite(url: URL!): Bookmark
}

# Feeds queries
type FeedsQuery {
  news(pagination: CursorPaginationInput!): FeedDocumentResults
  latestNews(pagination: CursorPaginationInput!): FeedDocumentResults
  favorites(pagination: CursorPaginationInput!): FeedBookmarkResults
  readingList(pagination: CursorPaginationInput!): FeedBookmarkResults
}

# Syndication queries and mutations
type SyndicationQuery {
  sources(pagination: OffsetPaginationInput!): SourceCollection
}

type SyndicationMutation {
  source(url: URL!): Source
}

# Custom Input Types
input CursorPaginationInput {
  from: String
  to: String
  limit: Int
}

input OffsetPaginationInput {
  offset: Int
  limit: Int
}

# Base Entities
interface Node {
  id: ID!
}

type User implements Node {
  id: ID!
  firstname: String!
  lastname: String!
  username: String!
}

type Image {
  name: String!
  url: URL!
  width: Int!
  height: Int!
  format: String!
}

type Document implements Node {
  id: ID!
  url: URL!
  lang: String!
  charset: String!
  title: String!
  description: String!
  image: Image
  createdAt: DateTime!
  updatedAt: DateTime!
  logEntries: [HTTPClientLog]
}

type Bookmark implements Node {
  id: ID!
  url: URL!
  lang: String!
  charset: String!
  title: String!
  description: String!
  image: Image
  updatedAt: DateTime!
  addedAt: DateTime!
  isFavorite: Boolean!
}

type Source implements Node {
  id: ID!
  url: URL!
  type: String!
  title: String!
  status: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  parsedAt: DateTime!
  logEntries: [HTTPClientLog]
}

type HTTPClientLog implements Node {
  id: ID!
  checksum: String!
  requestURI: URL!
  finalURI: URL!
  statusCode: Int!
  contentType: String!
  createdAt: DateTime!
}

type DocumentCollection {
  first: String!
  last: String!
  total: Int!
  limit: Int!
  results: [Document!]!
}

type SourceCollection {
  offset: Int!
  total: Int!
  limit: Int!
  results: [Source!]!
}

# NewsFeed, ReadingListFeed and FavoritesFeed
union FeedItem = Bookmark | Document

interface FeedResults {
  first: String!
  last: String!
  total: Int!
  limit: Int!
  results: [FeedItem!]!
}

type FeedDocumentResults implements FeedResults {
  first: String!
  last: String!
  total: Int!
  limit: Int!
  results: [Document!]!
}

type FeedBookmarkResults implements FeedResults {
  first: String!
  last: String!
  total: Int!
  limit: Int!
  results: [Bookmark!]!
}

# Feeds Subscription
# @TODO I need to double check those enums
enum FeedTopic {
  News
  Favorites
  ReadingList
}

enum FeedAction {
  Add
  Remove
}

interface FeedEvent {
  id: String!
  item: FeedItem!
  topic: FeedTopic!
  action: FeedAction!
}

type DocumentEvent implements FeedEvent {
  id: String!
  item: Document!
  topic: FeedTopic!
  action: FeedAction!
}

type BookmarkEvent implements FeedEvent {
  id: String!
  item: Bookmark!
  topic: FeedTopic!
  action: FeedAction!
}
